% Wikidata
\subsection{Wikidata}\label{section:wikidata}
Wikidata is an open, free, multilingual and collaborative knowledge base. It is a structured knowledge source for other Wikimedia projects. 
It tries to model the real world, meaning every concept, object, animal, person, etc.
Wikidata is mostly edited and extended by humans, which in general improves the quality of entries compared to fully-automated systems, 
because different editors can validate and correct occurring errors.
However, Wikidata, like most knowledge bases, is incomplete and therefore has to be operated under the \textit{Open World Assumption} (OWA).
OWA states that if a statement is not contained in a knowledge base, it is not necessarily false but rather unknown \cite{Galarraga2016}.

In Wikidata items and properties exist. Items are the aforementioned concepts, objects, etc. While properties are used to make claims about
items, e.g. \textit{photographic film (Q6293)} is a \textit{subclass of (P279)} \textit{data storage device (Q193395)} (see Figure~\ref{fig:class example}).
Each item and property has an unique identifier, which starts with the letter Q for items and the letter P for properties and is followed by a numeric code.
The identifiers in Wikidata are essential to avoid ambiguity and to make items and properties multilingual.

Items consist of labels, aliases and descriptions in different languages. 
Sitelinks connect items to their corresponding pages of Wikimedia projects like Wikipedia articles.
Most importantly item are described by statements. 
Statements are in their simplest form a pair of property and value, assigned to a specific item. A value is either a literal value or another item.
It should be noted that an item can have multiple statements with the same property. The set of statements with the same property is called statement group.
Statements can be annotated with qualifiers, which specify the context of the statement, e.g. population at a certain point of time.
Additionally, references can be used for statements to include its source. See Figure~\ref{fig:class example} for an example of a Wikidata item.
\begin{figure}
\centering
\includegraphics[width=\textwidth]{images/foundations/item_example.png}
\caption{Example of Wikidata class: photographic film (Q6239)}
\label{fig:class example}
\end{figure}

Following, the terms of item and statement are defined in the context of Wikidata.
\begin{definition}[Item]\label{definition:item}
An item is a tuple $(\mathit{id},  \mathit{label}, \mathit{aliases}, \mathit{description}, \mathit{sitelinks})$:
	\begin{itemize}
	\item $\mathit{id} \in \mathbb{N}$ is the numerical item ID;
	\item $\mathit{label} \in \mathit{String}$ is the English label of the item;
	\item $\mathit{aliases} \in \mathcal{P}(\mathit{String})$ is the set of English synonyms for the label;
	\item $\mathit{description} \in \mathit{String}$ is a short sentence describing the item;
	\item $\mathit{sitelinks} \in \mathit{String} \times \mathit{String}$ is a set of tuples $(\mathit{site}, \mathit{title})$, where $\mathit{site}$ refers to a specific site of the Wikimedia
	 projects, e.g. enwiki, and $\mathit{title}$ is the corresponding article title of the item on this site.
	\end{itemize}
\end{definition}
\begin{definition}[Statement]
A statement is a tuple $(\mathit{itemid}, \mathit{pid}, \mathit{value}, \mathit{refs}, \mathit{qualifiers})$:
\begin{itemize}
\item $\mathit{itemid} \in \mathbb{N}$ is a numerical item ID, to which the statement belongs;
\item $\mathit{pid} \in \mathbb{N}$ is a numerical property ID;
\item $\mathit{value}$ is either a constant value like string, int, etc., or an item ID;
\item $\mathit{refs}$ is a set of references, containing the source of information for the statement;
\item $\mathit{qualifiers}$ is a set of qualifiers, which further specifies the statement.
\end{itemize}
\end{definition}
In Wikidata, there is no strict distinction between classes and instances. Both groups are represented as items.
This leads to the issue, that recognizing, whether an item is a class or instance is not trivial.
Based on which statements connect two items, a distinction can be made.
A class is any item, which has instances, subclasses or is the subclass of another class.
In Wikidata, the properties \textit{instance of (P31)} and \textit{subclass of (P279)} exist, which describe this relation between items.
Therefore to identify whether an item is a class, it needs to be checked, whether the items fulfills any of the three above criteria.
\begin{definition}[Class]
Given a set of items $I$ and a set of statements $R$. $c = (\mathit{classid}, \_, \_, \_, \_)  \in I$ is a class, if at least one of the following assertions are true:
\begin{align*}
&\exists i=(\mathit{instanceid}, \_, \_, \_, \_) \in I \; \exists s=(\mathit{itemid}, \mathit{pid}, \mathit{value}, \_, \_) \in R :  \\
&\phantom{\exists i=(\mathit{instanceid}, \_, \_, \_, \_) \in I} \mathit{instanceid} = \mathit{itemid} \land \mathit{pid} = 31 \land \mathit{value} = \mathit{classid} \: 
	\textnormal{(has instance)}\\
&\exists s=(\mathit{itemid}, \mathit{pid}, \_, \_, \_) \in I: \mathit{itemid} = \mathit{classid} \land \mathit{pid} = 279 \: \textnormal{(is subclass)}\\
&\exists i=(subclassid, \_, \_, \_, \_) \in I \; \exists s=(itemid, pid, value, \_, \_) \in R : \\
&\phantom{\exists i=(\mathit{subclassid}, \_, \_, \_, \_)\in I } \mathit{itemid} = \mathit{subclassid} \land \mathit{pid} = 279 \land \mathit{value} = \mathit{classid} \: 
	\textnormal{(has subclass)}
\end{align*}
\end{definition}
$\_$ is used as an anonymous placeholder, for the purpose of not naming unused elements in tuples.
For example, \textit{photographic film (Q6293)} (Figure~\ref{fig:class example}) is a class, because it is the subclass of three other classes.

% Taxonomy
\subsection{Taxonomy}\label{section:taxonomy}

\textit{Ontologies} are sets of concepts and relations, which formally define how knowledge can be related and ordered in a context. Additionally it is possible for ontologies to
contain axioms used for validation and constraint enforcement. In comparison, a knowledge base like Wikidata can be seen as an instantiation of such an ontology,
since every knowledge base has to be conceptualized by an ontology \cite{Wong2012}. Different types of ontologies can grouped by their level of formality and expressiveness.
\fullcite{Wong2012} differentiates ontologies as lightweight and heavyweight ontologies (see Figure~\ref{fig:ontology spectrum}). 
\textit{Taxonomies} are concept or class hierarchies.
They typically represent a parent-child structure, which can be formalized with a single relationship called for example \textit{subclass-of} in the case of Wikidata.
The observed taxonomy in Wikidata belongs to the category of lightweight ontologies, specifically \textit{principled, informal hierarchies}, 
as the only enforced rule for the subclass-of relation is that it should connect two entities \cite{WikidataP279}.
\begin{figure}
\centering
\includegraphics[width=\textwidth]{images/foundations/wong2012_spectrum_of_ontology_kinds.png}
\caption{The spectrum of ontology kinds. \cite{Wong2012}}
\label{fig:ontology spectrum}
\end{figure}

For the purpose of developing a formal definition of the thesis' problem statement the notion of taxonomy needs to be formalized.
\fullcite{Cimiano2006} defines a heavyweight ontology, which includes a taxonomy, as follows:\\
``
	\begin{definition*}[Ontology]\label{Ontology}
		An \textnormal{ontology} is a structure
		\begin{equation*} 
			\mathcal{O} := (C, \taxon, R, \relsig, \relhier, \mathcal{A}, \attsig, \mathcal{T})
		\end{equation*}
		consisting of
		\begin{itemize}
			\item four disjoint sets $C$, $R$, $\mathcal{A}$, and $\mathcal{T}$ whose elements are called \textnormal{concept identifiers}, 
				\textnormal{relation identifiers}, \textnormal{attribute identifiers} and \textnormal{data types}, respectively,
			\item a semi-upper latice $\taxon$ on $C$ with top element $\rootc$, called \textnormal{concept hierarchy} or \textnormal{taxonomy},	
			\item a function $\relsig: R \rightarrow C^+$ called \textnormal{relation signature},
			\item a partial order $\relhier$ on $R$, called \textnormal{relation hierarchy}, where $r_1 \relhier r_2$ implies $\abs{\relsig (r_1)} = \abs{\relsig (r_2)}$ and
				$\proj{i}{\relsig (r_1)} \taxon \proj{i}{\relsig (r_2)}$, for each $1 \le i \le \abs{\relsig (r_1)}$, and
			\item a function $\attsig : \mathcal{A} \rightarrow C \times \mathcal{T}$, called \textnormal{attribute signature},
			\item a set $\mathcal{T}$ of datatypes such as strings, integers, etc.
		\end{itemize}
	\end{definition*}
	Hereby, $\proj{i}{t}$ is the i-th component of tuple $t$. [...] Further, a semi-upper lattice $\le$ fulfills the following conditions:
	\begin{align*}
		&\forall x (x \le x) \: \text{(reflexive)} \\
		&\forall x \forall y (x \le y \land y \le x \implies x = y) \: \text{(anti-symmetric)} \\
		&\forall x \forall y \forall z (x \le y \land y \le z \implies x \le z) \: \text{(transitive)}\\
		&\forall x x \le top \: \text{(top element)}\\
		&\forall x \forall y \exists z (z \ge \land z \ge y \land \forall w (w \ge x \land w \ge y \implies w \ge z)) \: \text{(supremum)}
	\end{align*}
	So every two elements have a unique most specific supremum.
''\\

A taxonomy can be modeled as a semi-upper lattice. This induces two important assumptions about the structure and to some degree completeness of the
observed taxonomies. First, there is only one \textit{root class}, top element of the lattice, of which every other class is (transitively) a subclass. Second,
because of the supremum property, the taxonomy is fully connected, which means each class, but the root class, has a superclass.
Wikidata's taxonomy does therefore not fulfill the definition by \fullcite{Cimiano2006}, as it is not fully connected.\\
In the following, new definitions will presented, which attempt to model an incomplete taxonomy based on the already presented data model and structure of Wikidata.
First, basic concepts of graphs will be introduced.
\begin{definition}[Directed graph]\label{directed graph}
	A \textnormal{directed graph} G is an ordered pair $G=(V, E)$, where $V$ is a set of vertices, and $E = \{ (v_1, v_2) \mid v_1, v_2 \in V \}$ 
	is a set of ordered pairs called directed edges, connecting the the vertices.
\end{definition}
\begin{definition}[Predecessor]\label{predecessor}
Let $G=(V, E)$ be a directed graph.
$v_1 \in V$ is a \textnormal{predecessor} of $v_2 \in V$, if there exists an edge so that $(v_1, v_2) \in E$.
Let $v \in V$ be a vertice of G, then $pred_G(v) = \{ w \mid (w, v) \in E \}$ is the set of predecessors of $v$.
\end{definition}
\begin{definition}[Successor]\label{successor}
$v_1 \in V$ is a \textnormal{successor} of $v_2 \in V$, if there exists an edge so that $(v_2, v_1) \in E$.
Let $v \in V$ be a vertice of G, then $succ_G(v) = \{ w \mid (v, w) \in E \}$ is the set of successors of $v$.
\end{definition}
\begin{definition}[Walk]\label{walk}
Let $G = (V, E)$ be a directed graph.
A \textnormal{walk} $W$ of length $n \in \mathbb{N}$ is a sequence of vertices $W=(v_1,\ldots, v_n)$ with $v_1,\ldots, 
v_n \in V$,  so that $(v_i, v_{i+1}) \in E \; \forall i=1,\ldots,n-1$.
\end{definition}
\begin{definition}[Cycle]\label{cycle}
A walk $W=(v_1,\ldots, v_n)$ of length $n$ is called a \textnormal{cycle}, if $v_1 = v_n$.
\end{definition}
\begin{definition}[Directed acyclic graph]\label{acyclic directed graph}
A directed graph $G$ is called \textnormal{directed acyclic graph}, if there are no cycles in $G$.
\end{definition}
In Wikidata, a class can have multiple superclasses, therefore a tree structure is not sufficient to model the taxonomy.
However a directed acyclic graph, can model the taxonomy. The acyclic constraint is necessary to ensure that no class is transitively a subclass of itself.
\textbf{TODO: define}
\begin{definition}[Connectedness]
\end{definition}
\begin{definition}[Component]
\end{definition}
\begin{definition}[Taxonomy]
A \textnormal{taxonomy} $T=(C, S)$ is a directed  acyclic graph, where $C$ is a set of \textnormal{class identifiers}, 
and $S$ is the set of edges, which describe the \textnormal{subclass-of relation}  between two classes. such that $c_1$ is the subclass of $c_2$, if $(c_1, c_2) \in S$.
\end{definition}
\begin{definition}[Subclass-of relation]\label{subclass of}
The transitive binary relation $\subclassof{T}$ on the taxonomy $T=(C, S)$ represents the subclass relationship
of two classes in $T$. Given $c_1, c_2 \in C$, $c_1 \subclassof{T} c_2$, if there is a walk $W=(c_1, \ldots, c_2)$ with length 
$n \ge 1$, which connects $c_1$ and $c_2$. \subclassof{T} is transitive,  $\forall c_1, c_2, c_3 \in C:
c_1 \subclassof{T} c_2 \land c_2 \subclassof{T} c_3 \implies c_1 \subclassof{T} c_3$.
\end{definition}
If the taxonomy defined by \fullcite{Cimiano2006} is mapped on this graph-based taxonomy model, the following
assumption is true, for $T=(C,S)$: \[ \abs{\{  c \in C \mid \neg \exists s \in C: c \subclassof{T} s \}} = 1 \]
Only one class in this taxonomy has no superclasses. This class is called \textit{root class}. However
in the case of Wikidata, this assumption does not hold true. The following state is the case:
\[ \abs{\{  c \in C \mid \neg \exists s \in C: c \subclassof{T} s \}} > 1 \]
There are classes other than the root class, which also have no superclasses. These classes will be called
\textit{unlinked classes}.
\begin{definition}[Root class]\label{root class}
Given a taxonomy $T=(C, S)$, the \textnormal{root class} $root_T$ is a specific, predefined class with no superclasses in 
$T$. For $root_T$, $\abs{succ_T(root_T)} = 0$ applies.
\end{definition}
\begin{definition}[Unlinked class]\label{unlinked class}
Given a taxonomy $T=(C,S)$ with a root class $root_T$, a class $u \in C$ is called \textnormal{unlinked class},
if $u \neq root_T \land \abs{succ_T(u)} = 0$.
\end{definition}
In Wikidata, the root class is \entity{} \cite{WikidataQ35120}. 
All other classes, which are not subclasses of \entity{}, are therefore either unlinked classes, or subclasses of unlinked classes.
In Section~\ref{section:taxonomy analysis}, it will be shown that the Wikidata taxonomy graph is not fully
connected. But the component, which contains root class \entity{}, contains $97\%$ of all classes.
This component will be referred to as \textit{root taxonomy} in later sections.

% Similarity
\subsection{Similarity}
\begin{itemize}
\item semantic similarity e.g. distributional similarity \\
	\fullcite{Lin1998} \\
	\fullcite{Rodriguez2003}
\item geometrical similarity e.g. distance based-similarity, cosine similarity
\end{itemize}
For the task of ontology learning \cite{Hazman2011} as well as classification, e.g. k-nearest-neighbors,
the concept of similarity is of importance. A basic intuition of similarity is for example given by 
\fullcite{Lin1998}. Similarity is related to the commonalities and differences between two objects.
More commonalities implies higher similarity. Vice versa, more differences implies lower similarity.
Two identical objects should have the maximum similarity. In addition, only identical objects should be
able to achieve maximum similarity. Typically, similarity can be defined as a binary function, which
maps two objects to a value in the interval $[0, 1]$. A value of $1$ represents identical input objects.
For this thesis, semantic and vector similarity measures will be used.
\textbf{TODO: example for Commonalities, Differences}\\
Vector similarity.\\
Semantic similarity measures are needed when comparing structures, which cannot be sufficiently represented
as vectors. These are for example words and classes in ontologies \textbf{citations needed}.
\fullcite{Rodriguez2003} develops a semantic similarity measure for comparing entity classes in ontologies.
Entity

% Problem statement 
\subsection{Problem statement}
The task of this thesis is the classification of unlinked classes in Wikidata. In other words a function
is needed, which given an unlinked class $u$ of a taxonomy $T = (C, S)$ with a root class $root_T$,
find an appropriate superclass for $T$. \fullcite{Doan2002} suggests that for the task of placing a class
into an appropriate position in $T$,
either finding the most similar class, most specific superclass, or most general subclasses of $u$,
are sensible approaches.
This induces that the appropriate superclass for an unlinked class $u$ is either the most similar class $c \in T$,
or one of the superclasses of $succ_T(c)$.
Therefore we can define the problem, as follows:
\begin{definition}[Problem definition]\label{problem definition}
Given a taxonomy $T = (C, S)$ with root class $root_T$ and a similarity function $sim$ over $T$,
find a function $f$, which, given an unlinked class $u \in C$, returns a class $s = f(u)$, fulfilling the following
criteria:
\textbf{TODO: define as the parents of the most similar class? for example german would be similar to english,
therefore the superclass for german should be language and not english}
\begin{align}
& \neg (s \subclassof{T} u) \: \textnormal{no child} \label{no child}\\
& s = \underset{c \in C}{\max(sim(u, s))} \: \textnormal{most similar class} \label{most similar class}
\end{align}
\end{definition}

% Similarity-based classification
\subsection{k-nearest-neighbors classification}
\fullcite{Chen2009}\\
\fullcite{Zhang2015}\\
Based on the characteristics of the classification problem, described by the problem statement, and the challenges attached to it,
the k-nearest-neighbor algorithm seems like an appropriate tool for solving the task. 

\textbf{Explain how kNN works.}
\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{images/foundations/knn_example.pdf}
\caption{Example for k-nearest neighbors for 3 classes with k=4 and k=10.}
\label{fig:kNN example}
\end{figure}
Nearest-neighbors classification is a lazy method, as it does not require training before testing.
This is useful for applications with high amounts of data, large numbers of classes, and changing data \cite{Zhang2015}.
For the considered use case of classification in Wikidata, these are very important strengths,
as the number of classes in the taxonomy is very high and Wikidata is being constantly edited.

% Language models (not needed specific language model will be introduced in neural networks
% \subsection{Language models}
%\begin{itemize}
%\item N-Gram \\
%	\fullcite{Jurafsky2014}
%\item Skip-Gram \\
%	\fullcite{Guthrie2006}
%\item Counting-based word representations \\ 
%	\fullcite{Levy2015}
%\item Predictive word representations \\
%	\fullcite{Levy2015}
%\end{itemize}
%A neural language model is used by the algorithm, developed in this thesis.
%Language models are used to assign a probability for a word occurring in a certain context.