
\subsection{Wikidata}\label{section:wikidata}
\textbf{TODO: Define entity in Wikidata, how are classes identified, etc.}
\fullcite{Galarraga2016}\\
Wikidata is a open, collaborative and user-driven knowledge base. Its main purpose is to serve as a structural knowledge store for other
Wikimedia projects like Wikipedia.
\begin{figure}
\centering
\includegraphics[width=\textwidth]{images/foundations/item_example.png}
\caption{Example of Wikidata class: photographic film (Q6239)}
\label{fig:class example}
\end{figure}


\subsection{Taxonomy}\label{section:taxonomy}

\textit{Ontologies} are sets of concepts and relations, which formally define how knowledge can be related and ordered in a context. Additionally it is possible for ontologies to
contain axioms used for validation and constraint enforcement. In comparison, a knowledge base like Wikidata can be seen as an instantiation of such an ontology,
since every knowledge base has to be conceptualized by an ontology \cite{Wong2012}. Different types of ontologies can grouped by their level of formality and expressiveness.
\fullcite{Wong2012} differentiates ontologies as lightweight and heavyweight ontologies (see Figure~\ref{fig:ontology spectrum}). 
\textit{Taxonomies} are concept or class hierarchies.
They typically represent a parent-child structure, which can be formalized with a single relationship called for example \textit{subclass-of} in the case of Wikidata.
The observed taxonomy in Wikidata belongs to the category of lightweight ontologies, specifically \textit{principled, informal hierarchies}, 
as the only enforced rule for the subclass-of relation is that it should connect two entities \cite{WikidataP279}.
\begin{figure}
\centering
\includegraphics[width=\textwidth]{images/foundations/wong2012_spectrum_of_ontology_kinds.png}
\caption{The spectrum of ontology kinds. \cite{Wong2012}}
\label{fig:ontology spectrum}
\end{figure}

For the purpose of developing a formal definition of the thesis' problem statement the notion of taxonomy needs to be formalized.
\fullcite{Cimiano2006} defines a heavyweight ontology, which includes a taxonomy, as follows:\\
``
	\begin{definition*}[Ontology]\label{Ontology}
		An \textnormal{ontology} is a structure
		\begin{equation*} 
			\mathcal{O} := (C, \taxon, R, \relsig, \relhier, \mathcal{A}, \attsig, \mathcal{T})
		\end{equation*}
		consisting of
		\begin{itemize}
			\item four disjoint sets $C$, $R$, $\mathcal{A}$, and $\mathcal{T}$ whose elements are called \textnormal{concept identifiers}, 
				\textnormal{relation identifiers}, \textnormal{attribute identifiers} and \textnormal{data types}, respectively,
			\item a semi-upper latice $\taxon$ on $C$ with top element $\rootc$, called \textnormal{concept hierarchy} or \textnormal{taxonomy},	
			\item a function $\relsig: R \rightarrow C^+$ called \textnormal{relation signature},
			\item a partial order $\relhier$ on $R$, called \textnormal{relation hierarchy}, where $r_1 \relhier r_2$ implies $\abs{\relsig (r_1)} = \abs{\relsig (r_2)}$ and
				$\proj{i}{\relsig (r_1)} \taxon \proj{i}{\relsig (r_2)}$, for each $1 \le i \le \abs{\relsig (r_1)}$, and
			\item a function $\attsig : \mathcal{A} \rightarrow C \times \mathcal{T}$, called \textnormal{attribute signature},
			\item a set $\mathcal{T}$ of datatypes such as strings, integers, etc.
		\end{itemize}
	\end{definition*}
	Hereby, $\proj{i}{t}$ is the i-th component of tuple $t$. [...] Further, a semi-upper lattice $\le$ fulfills the following conditions:
	\begin{align*}
		&\forall x x \le x \: \text{(reflexive)} \\
		&\forall x \forall y (x \le y \land y \le x \implies x = y) \: \text{(anti-symmetric)} \\
		&\forall x \forall y \forall z (x \le y \land y \le z \implies x \le z) \: \text{(transitive)}\\
		&\forall x x \le top \: \text{(top element)}\\
		&\forall x \forall y \exists z (z \ge \land z \ge y \land \forall w (w \ge x \land w \ge y \implies w \ge z)) \: \text{(supremum)}
	\end{align*}
	So every two elements have a unique most specific supremum.
''\\

A taxonomy can be modeled as a semi-upper lattice. This induces two important assumptions about the structure and to some degree completeness of the
observed taxonomies. First, there is only one \textit{root class}, top element of the lattice, of which every other class is (transitively) a subclass. Second,
because of the supremum property, the taxonomy is fully connected, which means each class, but the root class, has a superclass.
Wikidata's taxonomy does therefore not fulfill the definition by \fullcite{Cimiano2006}, as it is not fully connected.\\
In the following, new definitions will presented, which attempt to model an incomplete taxonomy based on the already presented data model and structure of Wikidata.
First, basic concepts of graphs will be introduced.
\begin{definition}[Directed graph]\label{directed graph}
	A \textnormal{directed graph} G is an ordered pair $G=(V, E)$, where $V$ is a set of vertices, and $E = \{ (v_1, v_2) \mid v_1, v_2 \in V \}$ 
	is a set of ordered pairs called directed edges, connecting the the vertices.
\end{definition}
\begin{definition}[Predecessor]\label{predecessor}
Let $G=(V, E)$ be a directed graph.
$v_1 \in V$ is a \textnormal{predecessor} of $v_2 \in V$, if there exists an edge so that $(v_1, v_2) \in E$.
Let $v \in V$ be a vertice of G, then $pred_G(v) = \{ w \mid (w, v) \in E \}$ is the set of predecessors of $v$.
\end{definition}
\begin{definition}[Successor]\label{successor}
$v_1 \in V$ is a \textnormal{successor} of $v_2 \in V$, if there exists an edge so that $(v_2, v_1) \in E$.
Let $v \in V$ be a vertice of G, then $succ_G(v) = \{ w \mid (v, w) \in E \}$ is the set of successors of $v$.
\end{definition}
\begin{definition}[Walk]\label{walk}
Let $G = (V, E)$ be a directed graph.
A \textnormal{walk} $W$ of length $n \in \mathbb{N}$ is a sequence of vertices $W=(v_1,\ldots, v_n)$ with $v_1,\ldots, 
v_n \in V$,  so that $(v_i, v_{i+1}) \in E \; \forall i=1,\ldots,n-1$.
\end{definition}
\begin{definition}[Cycle]\label{cycle}
A walk $W=(v_1,\ldots, v_n)$ of length $n$ is called a \textnormal{cycle}, if $v_1 = v_n$.
\end{definition}
\begin{definition}[Directed acyclic graph]\label{acyclic directed graph}
A directed graph $G$ is called \textnormal{directed acyclic graph}, if there are no cycles in $G$.
\end{definition}
In Wikidata, a class can have multiple superclasses, therefore a tree structure is not sufficient to model the taxonomy.
However a directed acyclic graph, can model the taxonomy. The acyclic constraint is necessary to ensure that no class is transitively a subclass of itself.
\begin{definition}[Taxonomy]
A \textnormal{taxonomy} $T=(C, S)$ is a directed  acyclic graph, where $C$ is a set of \textnormal{class identifiers}, 
and $S$ is the set of edges, which describe the \textnormal{subclass-of relation}  between two classes. such that $c_1$ is the subclass of $c_2$, if $(c_1, c_2) \in S$.
\end{definition}
\begin{definition}[Subclass-of relation]\label{subclass of}
The transitive binary relation $\subclassof{T}$ on the taxonomy $T=(C, S)$ represents the subclass relationship
of two classes in $T$. Given $c_1, c_2 \in C$, $c_1 \subclassof{T} c_2$, if there is a walk $W=(c_1, \ldots, c_2)$ with length 
$n \ge 1$, which connects $c_1$ and $c_2$. \subclassof{T} is transitive,  $\forall c_1, c_2, c_3 \in C:
c_1 \subclassof{T} c_2 \land c_2 \subclassof{T} c_3 \implies c_1 \subclassof{T} c_3$.
\end{definition}
If the taxonomy defined by \fullcite{Cimiano2006} is mapped on this graph-based taxonomy model, the following
assumption is true, for $T=(C,S)$: \[ \abs{\{  c \in C \mid \neg \exists s \in C: c \subclassof{T} s \}} = 1 \]
Only one class in this taxonomy has no superclasses. This class is called \textit{root class}. However
in the case of Wikidata, this assumption does not hold true. The following state is the case:
\[ \abs{\{  c \in C \mid \neg \exists s \in C: c \subclassof{T} s \}} > 1 \]
There are classes other than the root class, which also have no superclasses. These classes will be called
\textit{unlinked classes}.
\begin{definition}[Root class]\label{root class}
Given a taxonomy $T=(C, S)$, the \textnormal{root class} $root_T$ is a specific, predefined class with no superclasses in 
$T$. For $root_T$, $\abs{succ_T(root_T)} = 0$ applies.
\end{definition}
\begin{definition}[Unlinked class]\label{unlinked class}
Given a taxonomy $T=(C,S)$ with a root class $root_T$, a class $u \in C$ is called \textnormal{unlinked class},
if $u \neq root_T \land \abs{succ_T(u)} = 0$.
\end{definition}
In Wikidata, the root class is \entity{} \cite{WikidataQ35120}. 
All other classes, which are not subclasses of \entity{}, are therefore either unlinked classes, or subclasses of unlinked classes.
\textbf{TODO: Something is missing here maybe. The problem statement could follow here, but the required definition of similarity is missing. Maybe switch the order of similarity and taxonomy.}

\subsection{Similarity}
\begin{itemize}
\item semantic similarity e.g. distributional similarity \\
	\fullcite{Lin1998} \\
	\fullcite{Rodriguez2003}
\item geometrical similarity e.g. distance based-similarity, cosine similarity
\end{itemize}
For the task of ontology learning \cite{Hazman2011} as well as classification, e.g. k-nearest-neighbors,
the concept of similarity is of importance. A basic intuition of similarity is for example given by 
\fullcite{Lin1998}. Similarity is related to the commonalities and differences between two objects.
More commonalities implies higher similarity. Vice versa, more differences implies lower similarity.
Two identical objects should have the maximum similarity. In addition, only identical objects should be
able to achieve maximum similarity. Typically, similarity can be defined as a binary function, which
maps two objects to a value in the interval $[0, 1]$. A value of $1$ represents identical input objects.
For this thesis, semantic and vector similarity measures will be used.\\
Vector similarity.\\
Semantic similarity measures are needed when comparing structures, which cannot be sufficiently represented
as vectors. These are for example words and classes in ontologies \textbf{citations needed}.
\fullcite{Rodriguez2003} develops a semantic similarity measure for comparing entity classes in ontologies.
Entity

\subsection{Similarity-based classification}
\fullcite{Chen2009}\\
\fullcite{Zhang2015}\\

\textbf{Explain how kNN works.}
\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{images/foundations/knn_example.pdf}
\caption{Example for k-nearest neighbors for 3 classes with k=4 and k=10.}
\label{fig:kNN example}
\end{figure}
Nearest-neighbors classification is a lazy method, as it does not require training before testing.
This is useful for applications with high amounts of data, large numbers of classes, and changing data \cite{Zhang2015}.
For the considered use case of classification in Wikidata, these are very important strengths,
as the number of classes in the taxonomy is very high and Wikidata is being constantly edited.

\subsection{Text processing}
\begin{itemize}
\item N-Gram \\
	\fullcite{Jurafsky2014}
\item Skip-Gram \\
	\fullcite{Guthrie2006}
\item Counting-based word representations \\ 
	\fullcite{Levy2015}
\item Predictive word representations \\
	\fullcite{Levy2015}
\end{itemize}

\subsection{Problem statement}
The task of this thesis is the classification of unlinked classes in Wikidata. In other words a function
is needed, which given an unlinked class $u$ of a taxonomy $T = (C, S)$ with a root class $root_T$,
find an appropriate superclass for $T$. \fullcite{Doan2002} suggests that for the task of placing a class
into an appropriate position in $T$,
either finding the most similar class, most specific superclass, or most general subclasses of $u$,
are sensible approaches.
This induces that the appropriate superclass for an unlinked class $u$ is either the most similar class $c \in T$,
or one of the superclasses of $succ_T(c)$.
Therefore we can define the problem, as follows:
\begin{definition}[Problem definition]\label{problem definition}
Given a taxonomy $T = (C, S)$ with root class $root_T$ and a similarity function $sim$ over $T$,
find a function $f$, which, given an unlinked class $u \in C$, returns a class $s = f(u)$, fulfilling the following
criteria:
\textbf{TODO: define as the parents of the most similar class? for example german would be similar to english,
therefore the superclass for german should be language and not english}
\begin{align}
& \neg (s \subclassof{T} u) \: \textnormal{no child} \label{no child}\\
& s = \underset{c \in C}{\max(sim(u, s))} \: \textnormal{most similar class} \label{most similar class}
\end{align}
\end{definition}